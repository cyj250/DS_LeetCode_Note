# 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

**假设环境不允许存储 64 位整数（有符号或无符号）。**

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-integer
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

开始见到题没思路，单纯想到用数组存每次求余后的数字，却无法判断是否溢出。



**官方题解**

**思路**

可以一次反转一个数字，将其推到数字前边。

**算法**

反转整数的方法可以与反转字符串进行类比。

我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \text{rev}rev 的后面。最后，\text{rev}rev 将与 xx 相反。

要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。

```
//pop operation:
pop = x % 10;
x /= 10;

//push operation:
temp = rev * 10 + pop;
rev = temp;
```

这样做temp很容易溢出。

>1. rev/10>INT_MAX 或 rev/10<INT_MIN,一定溢出
>2. rev/10==INT_MAX&&pop>7,溢出。
>3. rev/10==INT_MIN&&pop<-8,溢出。

代码如下：

```c
int reverse(int x){
    int rev = 0;
    int p;
    while(x!=0){
        p = x%10;
        x=x/10;
        if(rev>INT_MAX/10||(rev==INT_MAX&&p>7)) return 0;
        if(rev<INT_MIN/10||(rev==INT_MIN&&p<-8)) return 0;
        rev = rev*10+p;
    }
    return rev;
}
```



**总结**

首先，本题实现数字反转的方法很巧妙，俺没想到，就像有一个栈一样。

判断是否溢出。